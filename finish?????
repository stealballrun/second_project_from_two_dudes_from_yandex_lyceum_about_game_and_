import os
import random
import pygame

one = [[None, None, None, None, None, None],
       [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), None],
       [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), None],
       [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), None],
       [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), None],
       [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), None],
       [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10)],
       [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)],
       [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)],
       [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7)],
       [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6)]]

two = [[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6)],
       [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
       [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)],
       [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)],
       [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10)],
       [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), None],
       [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), None],
       [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), None],
       [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), None],
       [(10, 0), (10, 1), (10, 2), (10, 3), (10, 4), (10, 5), None],
       [None, None, None, None, None, None]]

three = [[(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)],
         [(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6)],
         [(3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)],
         [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)],
         [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)],
         [None, (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)],
         [None, (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8)],
         [None, (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7)],
         [None, (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6)],
         [None, (10, 0), (10, 1), (10, 2), (10, 3), (10, 4), (10, 5)],
         [None, None, None, None, None, None]]

four = [[None, None, None, None, None, None],
        [None, (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5)],
        [None, (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6)],
        [None, (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7)],
        [None, (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8)],
        [None, (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)],
        [(5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)],
        [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)],
        [(7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)],
        [(8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6)],
        [(9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5)]]

field =  [[None, None, None, None, None, None],
          [None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None, None],
          [None, None, None, None, None, None, None],
          [None, None, None, None, None, None]]

b_one = [[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), None],
         [(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), None],
         [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), None],
         [(4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), None],
         [(5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), None],
         [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), None, None],
         [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), None, None],
         [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), None, None],
         [(9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), None, None],
         [(10, 1), (10, 2), (10, 3), (10, 4), (10, 5), None, None],
         [None, None, None, None, None, None]]

b_two = [[(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6)],
         [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)],
         [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)],
         [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)],
         [(6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9)],
         [None, (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), None],
         [None, (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), None],
         [None, (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5), (9, 6), None],
         [None, (10, 0), (10, 1), (10, 2), (10, 3), (10, 4), (10, 5), None],
         [None, None, None, None, None, None, None],
         [None, None, None, None, None, None]]

b_three = [[None, (1, 0), (1, 1), (1, 2), (1, 3), (1, 4)],
           [None, (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)],
           [None, (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6)],
           [None, (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7)],
           [None, (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)],
           [None, None, (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)],
           [None, None, (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)],
           [None, None, (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6)],
           [None, None, (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (9, 5)],
           [None, None, (10, 0), (10, 1), (10, 2), (10, 3), (10, 4)],
           [None, None, None, None, None, None]]

b_four = [[None, None, None, None, None, None],
          [None, None, (0, 0), (0, 1), (0, 2), (0, 3), (0, 4)],
          [None, None, (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5)],
          [None, None, (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6)],
          [None, None, (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)],
          [None, None, (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8)],
          [None, (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8)],
          [None, (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7)],
          [None, (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6)],
          [None, (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (8, 5)],
          [None, (9, 0), (9, 1), (9, 2), (9, 3), (9, 4)]]

b_five = [[None, None, None, None, None, None],
          [None, None, None, None, None, None, None],
          [None, (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), None],
          [None, (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), None],
          [None, (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), None],
          [None, (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), None],
          [(4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)],
          [(5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9)],
          [(6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8)],
          [(7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)],
          [(8, 1), (8, 2), (8, 3), (8, 4), (8, 5), (8, 6)]]

b_six = [[None, None, None, None, None, None],
         [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), None, None],
         [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), None, None],
         [(2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), None, None],
         [(3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), None, None],
         [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9), None, None],
         [(5, 2), (5, 3), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), None],
         [(6, 2), (6, 3), (6, 4), (6, 5), (6, 6), (6, 7), (6, 8), (6, 9), None],
         [(7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), None],
         [(8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7), None],
         [(9, 2), (9, 3), (9, 4), (9, 5), (9, 6), None]]
           
def opponent(color):
    if color == WHITE:
        return BLACK
    else:
        return WHITE

def print_board():
        a = ''
        b = []
        for i in field:
            q = []
            for j in i:
                if j == None:
                    b.append('  ')
                else:
                    q.append(j[1])
            b.append('\t'.join(q))
        a = '\n'.join(b)
        print(a)

class Board:
    def __init__(self):
        self.color = WHITE
        self.field =  [[None, None, None, None, None, None],
                       [None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None, None],
                       [None, None, None, None, None, None, None],
                       [None, None, None, None, None, None]]
        field = self.field
        
    def correct_coords(col, row):
        if row >= 0 and col >= 0 and col < 11 and row < len(field[col]):
            return True
        return False
    
    def current_player_color(self):
        return self.color
 
    def out(self, col, row):
        obj = self.field[col][row][0]
        if obj[0] is None:
            return None
        piece = Pieces[obj[0]][obj[1]]
        return piece.char()[1]
 
    def move_piece(self, col, row, col1, row1):
        if not correct_coords(col, row) or not correct_coords(col1, row1):
            return False
        if row == row1 and col == col1:
            return False
        obj = self.field[col][row][0]
        if obj[0] is None:
            return False
        piece = Pieces[obj[0]][obj[1]]
        if piece.get_color() != self.color:
            return False
        if self.field[col1][row1][0] is None:
            if not piece.can_move(self, col, row, col1, row1):
                return False
        else:
            obj1 = self.field[col1][row1][0]
            piece1 = Pieces[obj1[0]][obj1[1]]            
            if piece1.get_color() == opponent(piece.get_color()):
                if not piece.can_eat(self, col, row, col1, row1):
                    return False
                else:
                    Pieces[obj[0]][obj[1]] = None
            else:
                return False
        piece.col = col1
        piece.row = row1
        self.field[col][row] = None
        self.field[col1][row1] = piece.char()
        self.color = opponent(self.color)
        if piece.check_Q:
            Pieces[obj[0]][obj[1]] = Queen(piece.col, piece.row, piece.color, piece.N)
            self.field[col1][row1] = Pieces[obj[0]][obj[1]].char()
        field = self.field
        return True
    
    def start(self):
        for i in range(len(Pieces)):
            for j in range(len(Pieces[i])):
                piece = Pieces[i][j]
                char = piece.char()
                self.field[char[2][0]][char[2][1]] = char
        field = self.field

class King:
    def __init__(self, col, row, color, N):
        self.color = color
        self.col = col
        self.N = N
        self.color = color        
        self.step = 0

    def get_color(self):
        return self.color

    def char(self):
        if self.color == WHITE:
            ans = 'wK'
        else:
            ans = 'bK'
        return (self.color - 1, self.N), ans, (self.col, self.row)

    def can_move(self, col, row):
        if self.row == row and (self.col + 1 == col or self.col - 1 == col):
            return True
        
        elif (col, row) == one[self.col][self.row]:
            return True
            
        elif (col, row) == two[self.col][self.row]:
            return True
        
        elif (col, row) == four[self.col][self.row]:
            return True
        
        elif (col, row) == three[self.col][self.row]:
            return True
        
        else:
            return False
        
    def can_eat(self, col, row):
        return self.can_move(self, col, row)
    
    def check_Q(self, col, row):
        return False


class Pawn:
 
    def __init__(self, col, row, color, N):
        self.row = row
        self.col = col
        self.color = color
        self.N = N
        self.step = 0
 
    def char(self):
        if self.color == WHITE:
            ans = 'wP'
        else:
            ans = 'bP'
        return (self.color - 1, self.N), ans, (self.col, self.row)
 
    def get_color(self):
        return self.color
 
    def can_move(self, col, row):
        if self.col != col:
            return False
 
        if self.color == WHITE:
            direction = 1
        else:
            direction = -1
 
        if self.row + direction == row:
            return True
 
        if self.step == 0 and self.row + 2 * direction == row and field[self.col][self.row + direction] == None:
            return True
        
        return False
    
    def can_eat(self, col, row):
        if direction == 1:
            if (col, row) == one[self.col][self.row]:
                return True
            
            elif (col, row) == two[self.col][self.row]:
                return True
            
            else:
                return False
            
        else:
            if (col, row) == four[self.col][self.row]:
                return True
            
            elif (col, row) == three[self.col][self.row]:
                return True
            
            else:
                return False            
    
    def check_Q(self, col, row):
        if direction == 1 and len(field[col]) == row + 1:
            return True
        if direction == -1 and row == 0:
            return True
        return False


class Knight:
    def __init__(self, col, row, color, N):
        self.color = color
        self.col = col
        self.N = N
        self.color = color        
        self.step = 0

    def get_color(self):
        return self.color

    def char(self):
        if self.color == WHITE:
            ans = 'wN'
        else:
            ans = 'bN'
        return (self.color - 1, self.N), ans, (self.col, self.row)

    def can_move(self, col, row):
        c1, r1 = one[self.col][self.row]
        c2, r2 = two[self.col][self.row]
        c3, r3 = three[self.col][self.row]
        c4, r4 = four[self.col][self.row]
        if one[self.col + 2][self.row] == (col, row):
            return True
        
        elif two[self.col + 2][self.row] == (col, row):
            return True
        
        elif three[self.col - 2][self.row] == (col, row):
            return True
        
        elif four[self.col - 2][self.row] == (col, row):
            return True
        
        elif one[c1][r1] == (col, row - 1) or one[c1][r1] == two[col][row]:
            return True
        
        elif two[c2][r2] == (col, row - 1) or two[c2][r2] == one[col][row]:
            return True
        elif three[c3][r3] == (col, row + 1) or three[c3][r3] == four[col][row]:
            return True
        
        elif four[c4][r4] == (col, row + 1) or four[c4][r4] == three[col][row]:
            return True
        
        else:
            return False

    def can_attack(self, col, row):
        return self.can_move(self, col, row)
    
    def check_Q(self, col, row):
        return False


class Rook:
    def __init__(self, col, row, color, N):
        self.color = color
        self.col = col
        self.N = N
        self.color = color        
        self.step = 0

    def get_color(self):
        return self.color

    def char(self):
        if self.color == WHITE:
            ans = 'wR'
        else:
            ans = 'bR'
        return (self.color - 1, self.N), ans, (self.col, self.row)

    def can_move(self, col, row):
        if self.col == col and self.row < row:
            for i in range(self.row, row - 1):
                if field[col][i + 1] != None:
                    return False
            return True
        elif self.col == col and self.row > row:
            for i in range(row, self.row - 1):
                if field[col][i + 1] != None:
                    return False
            return True
        elif self.col > col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and one[c1][r1] != None:
                    с1, r1 = one[c1][r1]
                else:
                    c1 = None
                if c2 != None  and four[c2][r2] != None:
                    с2, r2 = four[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        elif self.col < col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and two[c1][r1] != None:
                    с1, r1 = two[c1][r1]
                else:
                    c1 = None
                if c2 != None  and three[c2][r2] != None:
                    с2, r2 = three[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        return False
        
    def can_eat(self, col, row):
        return self.can_move(self, col, row)
    
    def check_Q(self, col, row):
        return False

class Bishop:
    def __init__(self, col, row, color, N):
        self.color = color
        self.col = col
        self.N = N
        self.color = color        
        self.step = 0

    def get_color(self):
        return self.color

    def char(self):
        if self.color == WHITE:
            ans = 'wB'
        else:
            ans = 'bB'
        return (self.color - 1, self.N), ans, (self.col, self.row)

    def can_move(self, col, row):
        c1 = self.col
        c2 = self.col
        r1 = self.r
        r2 = self.r
        if self.col - col % 2 == 0:
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_two[c1][r1] != None:
                    с1, r1 = b_two[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_five[c2][r2] != None:
                    с2, r2 = b_five[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
        if self.col < col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_one[c1][r1] != None:
                    с1, r1 = b_one[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_three[c2][r2] != None:
                    с2, r2 = b_three[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        elif self.col > col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_four[c1][r1] != None:
                    с1, r1 = b_four[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_five[c2][r2] != None:
                    с2, r2 = b_five[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        return False
        
    def can_eat(self, col, row):
        return self.can_move(self, col, row)
    
    def check_Q(self, col, row):
        return False

class Qween:
    def __init__(self, col, row, color, N):
        self.color = color
        self.col = col
        self.N = N
        self.color = color        
        self.step = 0

    def get_color(self):
        return self.color

    def char(self):
        if self.color == WHITE:
            ans = 'wQ'
        else:
            ans = 'bQ'
        return (self.color - 1, self.N), ans, (self.col, self.row)

    def can_move(self, col, row):
        if self.col - col % 2 == 0:
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_two[c1][r1] != None:
                    с1, r1 = b_two[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_five[c2][r2] != None:
                    с2, r2 = b_five[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
        if self.col < col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_one[c1][r1] != None:
                    с1, r1 = b_one[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_three[c2][r2] != None:
                    с2, r2 = b_three[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
        elif self.col > col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and b_four[c1][r1] != None:
                    с1, r1 = b_four[c1][r1]
                else:
                    c1 = None
                if c2 != None  and b_five[c2][r2] != None:
                    с2, r2 = b_five[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
        if self.col == col and self.row < row:
            for i in range(self.row, row - 1):
                if field[col][i + 1] != None:
                    return False
            return True
        elif self.col == col and self.row > row:
            for i in range(row, self.row - 1):
                if field[col][i + 1] != None:
                    return False
            return True
        elif self.col > col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and one[c1][r1] != None:
                    с1, r1 = one[c1][r1]
                else:
                    c1 = None
                if c2 != None  and four[c2][r2] != None:
                    с2, r2 = four[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        elif self.col < col:
            c1 = self.col
            c2 = self.col
            r1 = self.r
            r2 = self.r
            while c1 != col - 1 and c2 != col - 1:
                if c1 != None  and two[c1][r1] != None:
                    с1, r1 = two[c1][r1]
                else:
                    c1 = None
                if c2 != None  and three[c2][r2] != None:
                    с2, r2 = three[c2][r2]
                else:
                    c2 = None
            if r1 == row or r2 == row:
                return True
            else:
                return False
        return False

            
        
    def can_eat(self, col, row):
        return self.can_move(self, col, row)
    
    def check_Q(self, col, row):
        return False
    
Pieces = [[Pawn(1, 0, 1, 0), Pawn(2, 1, 1, 1), Pawn(3, 2, 1, 2), Pawn(4, 3, 1, 3),
           Pawn(5, 4, 1, 4), Pawn(6, 3, 1, 5), Pawn(7, 2, 1, 6), Pawn(8, 1, 1, 7),
           Pawn(9, 0, 1, 8), King(6, 0, 1, 9), Qween(4, 0, 1, 10), Rook(2, 0, 1, 11),
           Rook(8, 0, 1, 12), Knight(3, 0, 1, 13), Knight(7, 0, 1, 14), Bishop(5, 0, 1, 15),
           Bishop(5, 1, 1, 16), Bishop(5, 2, 1, 17)],
          [Pawn(1, 6, 2, 0), Pawn(2, 6, 2, 1), Pawn(3, 6, 2, 2), Pawn(4, 6, 2, 3),
           Pawn(5, 6, 2, 4), Pawn(6, 6, 2, 5), Pawn(7, 6, 2, 6), Pawn(8, 6, 2, 7),
           Pawn(9, 6, 2, 8), King(6, 9, 2, 9), Qween(4, 9, 2, 10), Rook(2, 7, 2, 11),
           Rook(8, 7, 2, 12), Knight(3, 8, 2, 13), Knight(7, 8, 2, 14), Bishop(5, 10, 2, 15),
           Bishop(5, 9, 2, 16), Bishop(5, 8, 2, 17)]]


#  полетели. поравь очепятки в названиях спрайта


class figures(pygame.sprite.Sprite):
    image_pawn_white_green = load_image("image_pawn_white_green.png")
    image_pawn_white_red = load_image("image_pawn_white_red.png")
    image_pawn_white_blue = load_image("image_pawn_white_blue.png")
    image_pawn_white_green = load_image("image_pawn_white_green.png")
    image_pawn_white_green = load_image("image_pawn_white_green.png")
    image_pawn_white_green = load_image("image_pawn_white_green.png")
    image_pawn_white_red = load_image("image_pawn_white_red.png")
    image_pawn_white_blue = load_image("image_pawn_white_blue.png")
    image_pawn_black_green = load_image("image_pawn_black_green.png")
    image_pawn_black_red = load_image("image_pawn_black_red.png")
    image_pawn_black_blue = load_image("image_pawn_black_blue.png")    
    
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_green = load_image("image_bishop_white_green.png")
    image_bishop_white_red = load_image("image_bishop_white_red.png")
    image_bishop_white_blue = load_image("image_bishop_white_blue.png")
    image_bishop_black_green = load_image("image_bishop_black_green.png")
    image_bishop_black_red = load_image("image_bishop_black_red.png")
    image_bishop_black_blue = load_image("image_bishop_black_blue.png")     
    
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_green = load_image("image_rook_white_green.png")
    image_rook_white_red = load_image("image_rook_white_red.png")
    image_rook_white_blue = load_image("image_rook_white_blue.png")
    image_rook_black_green = load_image("image_rook_black_green.png")
    image_rook_black_red = load_image("image_rook_black_red.png")
    image_rook_black_blue = load_image("image_rook_black_blue.png") 
    
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_green = load_image("image_knight_white_green.png")
    image_knight_white_red = load_image("image_knight_white_red.png")
    image_knight_white_blue = load_image("image_knight_white_blue.png")
    image_knight_black_green = load_image("image_knight_black_green.png")
    image_knight_black_red = load_image("image_knight_black_red.png")
    image_knight_black_blue = load_image("image_knight_black_blue.png") 
    
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_green = load_image("image_queen_white_green.png")
    image_queen_white_red = load_image("image_queen_white_red.png")
    image_queen_white_blue = load_image("image_queen_white_blue.png")
    image_queen_black_green = load_image("image_queen_black_green.png")
    image_queen_black_red = load_image("image_queen_black_red.png")
    image_queen_black_blue = load_image("image_queen_black_blue.png") 
    
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_green = load_image("image_king_white_green.png")
    image_king_white_red = load_image("image_king_white_red.png")
    image_king_white_blue = load_image("image_king_white_blue.png")
    image_king_black_green = load_image("image_king_black_green.png")
    image_king_black_red = load_image("image_king_black_red.png")
    image_king_black_blue = load_image("image_king_black_blue.png")     

    def __init__(self, group):
        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite
        super().__init__(group)
        for i in range(91):   # создаю поле завтра обсудим а то слетело дерьмо
            self.image + str(i) = figures.image    # здесь потом перечислю все фигуры, что сверху при создания поля
        #self.rect = self.image.get_rect() это не надо
        # перемещаем прямоугольник
        self.rect.topleft = ((random.randint(0, width - self.rect.width), random.randint(0, height - self.rect.height)))

    # Поручим бомбочке получать событие и взрываться самой
    def get_event(self, event):
        if self.rect.collidepoint(event.pos):
            if self.image is in figures:
                if self.rect.collidepoint(event.pos):
                    if True:# класс и здесь полетел тест приду допишу
                        piese[found(self.image_previost)] = "dead"
                        piese[found(self.image)] = [get_event]  # тоже слетело с доски возвращало значение, но бехз кода доски не работает
                        self.image = self.image_previost
                     # здесь кажадый кусок твоего кода от каждой темы, когда покажешь надо вместе сделать здесь


# группа, содержащая все спрайты
all_sprites = pygame.sprite.Group()

for i in range(91):
    # тоже доска воспроизводит куски
    figures(all_sprites)

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT or piece[1][9] != "dead" or piece[0][9] != "dead":
            running = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            for figures in all_sprites:
                figures.get_event(event)
    screen.fill(pygame.Color("white"))
    all_sprites.draw(screen)
    pygame.display.flip()

pygame.quit()
